# 프론트엔드 면접 예상 질문 모음
***
## HTTP
### HTTP란?
HypterText Transfer Protocol의 약자로, 인터넷 상에서 클라이언트와 서버가 어떻게 메시지를 교환할 지를 정해놓은 규칙
### HTTP의 특징
- **비연결식** : 클라이언트가 서버에게 정보를 요청하면, 서버는 클라이언트에게 응답 코드와 내용을 전송하고 클라이언트와의 연결을 종료한다.
- **무상태성** : 비연결로 인해 서버는 클라이언트에 대한 정보를 저장하지 않는다. 이를 해결하기 위해 쿠키, 세션, OAuth 등을 사용할 수 있다.
***
## 동기 / 비동기
### AJAX란?
**Asynchronous Javascript And XML**<br>
자바스크립트를 이용해 비동기적으로 서버와 브라우저가 데이터를 교환하는 통신 방식<br>
보통은 서버로부터 전체 페이지를 갱신해야 하지만 AJAX를 사용하면 일부분만 갱신하고 동일한 효과를 볼 수 있다.
### Promise란 무엇이며 코드가 어떻게 구성되었는가?
비동기 처리를 위해 사용하는 객체로 pending, fulfilled, rejected 3개의 상태를 갖는다.
```javascript
// Promise 객체 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  if (/* 비동기 작업 수행 성공 */) {
    resolve('result');
  } else { // 비동기 작업 수행 실패
    reject('failure reason');
  }
})
```
### Promise와 Callback의 차이점은 무엇이며 각각의 장단점?
[콜백의 문제점과 Promise를 사용하는 이유](https://yuddomack.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%9C%EB%B0%B1%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0)<br>
둘다 자바스크립트에서 비동기 처리를 위해 사용하는 패턴<br>
**콜백**
- 장점 : 재사용 가능, 비동기 처리
- 단점 : 콜백 헬, 비동기 간 경쟁 관계, 콜백이 여러 분기에 대해 제어권을 갖는 경우(코드 테스트 어려움) → 이들을 Promise를 통해서 해결 가능

**Promise**
- 장점 : `then`, `catch` 등의 메서드를 사용해 체인 형태로 callback depth를 균일화(콜백 헬 해결), `Promise.all`을 사용해 경쟁 문제 해결, Promise는 한 번만 실행되므로 비동기요청에 대한 제어와 비즈니스 로직을 분리 가능
- 단점 : 콜백 헬보다는 낫지만 여전히 코드 장황. Promise는 생성 시 바로 실행되므로 불필요한 동작 방지해야 함.
### Async, Await이 무엇이며, 사용해 본 경험?
Promise를 좀 더 쉽게 사용할 수 있도록 하는 문법<br>
`async`는 하나의 비동기 함수를 정의하며, 자동으로 Promise를 return<br>
`await`은 `async`가 붙은 함수 내부에서 사용<br>
`async 함수의 실행 일시 중지` → `전달된 Promise의 해결 기다림` → `async 함수의 실행 재개 후 결과 값 반환`

<br>
영화 정보를 가져오는 API를 사용해 웹 페이지를 구축하는 프로젝트를 진행한 적 있음.<br>

사용자에게 로딩 중임을 나타내는 화면을 표시하고 `async`, `await` 을 사용한 API 호출이 완료되면 화면에 나타나도록 함.

### Async, Await, Promise의 차이?
[async, awiat이 Promise를 사라지게 할 수 있는 이유](https://medium.com/@constell99/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-async-await-%EA%B0%80-promises%EB%A5%BC-%EC%82%AC%EB%9D%BC%EC%A7%80%EA%B2%8C-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%9E%88%EB%8A%94-6%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0-c5fe0add656c)<br>
Promise를 좀 더 쉽게 사용할 수 있도록 한 문법으로 함수의 앞 부분에 `async` 키워드를 추가하고, 함수 내부에서 Promise의 앞 부분에 `await` 키워드를 사용한다.<br>
비동기 코드의 겉모습과 동작을 동기 코드와 유사하게 만들어 주며, 에러 처리를 위해 `try`, `catch`를 사용해야 한다.
***
## 쓰레드 / 프로세스
### 쓰레드와 프로세스 차이
[쓰레드와 프로세스 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)<br>
**개념만**<br>
프로세스는 운영체제로부터 할당 받는 자원의 단위이고, 쓰레드는 프로세스가 할당받은 자원을 사용하는 실행 단위이다.<br>
멀티 프로세싱보다 멀티 스레드를 하는 이유는 프로세스를 생성해 자원을 할당받는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있기 때문<br>
**모범 답안**<br>
프로세스와 스레드는 개념의 범위부터 다르다. 스레드는 프로세스 안에 포함되어 있기 때문이다.<br>

운영체제가 프로세스에게 Code/Data/Stack/Heap 메모리 영역을 할당해 주고 최소 작업 단위로 삼는 반면, 스레드는 프로세스 내에서 Stack 메모리 영역을 제외한 다른 메모리 영역을 같은 프로세스 내 다른 스레드와 공유한다.<br>

프로세스는 다른 프로세스와 정보를 공유하려면 IPC를 사용하는 등의 번거로운 과정을 거쳐야 하지만, 스레드는 기본 구조 자체가 메모리를 공유하는 구조이기 때문에 다른 스레드와 정보 공유가 쉽다. 때문에 멀티태스킹보다 멀티스레드가 자원을 아낄 수 있게 된다. 다만 스레드의 스케줄링은 운영체제가 처리하지 않기 때문에 프로그래머가 직접 동기화 문제에 대응할 수 있어야 한다.<br>