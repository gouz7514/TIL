## 자동화된 테스트
### 자동화된 테스트란?
코드의 동작을 확인하는 루틴

자동화된 테스트는 테스트 작업이 시스템에서 수행된다.<br />
한번 테스트 세트를 작성한 이후에는 앱을 변경할 때 수동 테스트를 수행하지 않아도 원래 의도대로 코드가 작동하는지 확인할 수 있다.
***
### 테스트를 만들어야 하는 이유
1. 시간 절약 가능
2. 문제를 그저 식별하는 것이 아니라 예방 가능
3. 코드를 더 매력적으로 만든다
4. 팀이 함께 일하는 것을 돕는다
***
### 기초 테스팅 전략
[TDD : Test Driven Development](https://en.wikipedia.org/wiki/Test-driven_development)<br />
어디서부터 테스트를 작성해야 할 지 종잡을 수 없다면 다음에 새로운 기능을 넣거나 버그를 수정하는 등, 코드를 변경할 일이 있을 때 첫 테스트를 작성할 수 있다.
***
### 첫번째 테스트 작성하기
#### 버그 식별하기
```bash
>>> import datetime
>>> from django.utils import timezone
>>> from polls.models import Question
>>> # create a Question instance with pub_date 30 days in the future
>>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
>>> # was it published recently?
>>> future_question.was_published_recently()
True
```
30일 뒤에 즉, 미래에 만들어졌음에도 `was_published_recnetly`가 true를 리턴함

#### 버그를 노출하는 테스트 만들기
```python
# polls/tests.py
import datetime

from django.test import TestCase
from django.utils import timezone

from .models import Question


class QuestionModelTests(TestCase):

    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)
```

#### 테스트 실행
shell에서 다음과 같이 실행
```shell
python manage.py test polls
```
```shell
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F
======================================================================
FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/hakjaekim/Desktop/VSC/mysite/polls/tests.py", line 14, in test_was_published_recently_with_future_question
    self.assertIs(future_question.was_published_recently(), False)
AssertionError: True is not False

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
Destroying test database for alias 'default'...
```
- manage.py test polls는 polls 애플리케이션에서 테스트를 찾음
- django.test.Testcase 클래스의 서브 클래스 찾음
- 테스트 목적으로 특별한 데이터베이스 만듦
- 테스트 메소드 : 이름이 test로 시작하는 것 찾음
- test_was_published_recently_with_future_question에서 pub_date 필드가 30일 미래인 Question 인스턴스를 생성
- assertIs() 메소드를 사용해 우리는 False가 반환되기를 원함에도 was_published_recently() 가 True를 반환한다는 것을 확인

#### 버그 수정
```python
# polls/models.py
def was_published_recently(self):
    now = timezone.now()
    return now - datetime.timedelta(days=1) <= self.pub_date <= now
```

#### 보다 포괄적인 테스트
```python
# polls/tests.py
def test_was_published_recently_with_old_question(self):
    """
    was_published_recently() returns False for questions whose pub_date
    is older than 1 day.
    """
    time = timezone.now() - datetime.timedelta(days=1, seconds=1)
    old_question = Question(pub_date=time)
    self.assertIs(old_question.was_published_recently(), False)

def test_was_published_recently_with_recent_question(self):
    """
    was_published_recently() returns True for questions whose pub_date
    is within the last day.
    """
    time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
    recent_question = Question(pub_date=time)
    self.assertIs(recent_question.was_published_recently(), True)
```
***
### 뷰 테스트

***