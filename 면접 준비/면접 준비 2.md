# JS 기본 지식, ES6, DOM, GC
***
## JS 기본 지식
### JS는 어떤 언어인지
웹을 위한 인터프리터 언어이자 스크립트 언어이다.<br>
(인터프리터 언어 : 한줄한줄 해석해 바로 명령어를 실행하는 언어)<br>
(스크립트 언어 : 응용 소프트웨어를 제어하는 컴퓨터 프로그래밍 언어)
<br>

**역할**<br>
- HTML 페이지 변경 및 HTML 엘리먼트, 콘텐츠의 추가/제거
- CSS 및 HTML 엘리먼트의 스타일 변경
- 사용자와 상호작용, 폼의 유효성 검증
- 마우스, 키보드 이벤트에 대한 스크립트 실행
- AJAX 기술을 이용한 웹 서버와 통신

**한계**<br>
- OS에 직접 접근할 수 없으며, 하드디스크를 읽거나 쓸 수 없고, 다른 프로그램도 호출할 수 없다.
- 일반적으로 자바스크립트는 자체 도메인에 대해서만 제한없이 네트워크 요청을 보낼 수 있다.

### JS는 싱글 스레드 언어? / 장단점
[왜 자바스크립트는 싱글 스레드일까?](https://chanyeong.com/blog/post/44)<br>
자바스크립트는 하나의 메인 스레드와 하나의 콜스택을 갖고 있어 싱글 스레드가 맞지만, 자바스크립트 런타임은 싱글 스레드가 아니다.<br>
싱글 스레드이기 때문에 데드락 같은 문제나 복잡한 시나리오를 고민할 필요는 없으나, 호출 스택에 처리 시간이 어마어마하게 오래 걸리는 함수가 있다면 브라우저는 해당 함수가 실행되는 동안 아무것도 하지 못하고 가만히 있게 된다.<br>

### JS 동작 원리
[JS 동작 원리](https://asfirstalways.tistory.com/362)<br>
자바스크립트 엔진은 자바스크립트로 작성한 코드를 해석하고 실행하는 인터프리터이다.<br>
구글의 V8을 비롯해 대부분의 자바스크립트 엔진은 크게 세 영역(Call Stack, Heap, Task Queue)으로 나뉜다.<br>
추가적으로 Event loop가 존재해 Task Queue에 들어가는 task들을 관리함.

#### Call Stack
**자바스크립트에서 수행해야 할 함수들을 순차적으로 스택에 담아 처리**<br>
자바스크립트는 단 하나의 호출 스택을 사용<br>
하나의 함수가 실행되면 이 함수의 실행이 끝날 때까지 다른 어떤 task도 수행 불가<br>
요청이 들어올 때마다 해당 요청을 순차적으로 호출 스택에 담아 처리<br>
메소드가 실행되면 Call Stack에 새로운 프레임이 push되고 메소드의 실행이 끝나면 해당 메소드는 pop되는 원리<br>

#### Web API
**웹 브라우저에서 제공하는 API로 AJAX나 Timeout등의 비동기 작업을 실행**<br>

#### Task Queue (Event Queue)
**Web API에서 넘겨받은 Callback함수를 저장**<br>
처리해야 하는 Task들을 임시 저장하는 대기 큐. Call Stack이 비었을 때 먼저 대기열에 들어온 순서대로 수행됨<br>
자바스크립트에서 비동기로 호출되는 함수들은 Call Stack에 쌓이지 않고 Task Queue에 enqueue된다.<br>
이벤트 루프는 현재 실행 중인 task가 없는지와 Task queue에 task가 있는지를 반복적으로 확인한다<br>
queue에 처리해야 할 이벤트(task)가 존재하면 해당 이벤트를 처리하거나 작업을 수행한다.<br>
그리고 다시 qeuue로 돌아와 새로운 이벤트가 존재하는지 파악

#### Event loop
**Call Stack이 비어있다면 Task Queue의 작업을 Call Stack으로 옮김**<br>

> **Q** : javascript는 어떻게 한번에 여러 요청을 처리하는지?<br>
**A** : 자바스크립트가 비동기 코드를 어떻게 동작시키는지 알기 위해 자바스크립트의 동작 원리에 대해서 알아야 한다.<br>
자바스크립트는 Call Stack, Web API, Task Queue, Event Loop 요소들이 동작함.<br>
**Call Stack** 자바스크립트에서 수행해야 할 함수들을 순차적으로 스택에 담아 처리한다.<br>
**Web API** 웹 브라우저에서 제공하는 API로 AJAX나 Timeout등의 비동기 작업을 실행<br>
**Task Queue** Web API에서 넘겨받은 Callback함수를 저장<br>
**Event Loop** Call Stack이 비어있다면 Task Queue의 작업을 Call Stack으로 옮김<br>
`비동기 콜백이 발생하면 web API 호출됨` → `web API는 콜백 함수를 이벤트 큐에 밀어 넣음` → `Call Stack이 비어있으면 이벤트 루프가 이벤트 큐의 작업을 Call Stack으로 옮김`<br>
이러한 비동기 콜백을 사용해 자바스크립트는 싱글 스레드지만 한번에 여러 요청을 처리할 수가 있다.

### 타입
정수만을 위한 타입이 없으며, 모든 수를 실수로 처리<br>
**Primitive** - boolean, string, number, undefined, null, symbol(ES6. 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용)<br>
`undefined` : 선언만 되어있고 값은 없는 상태. `===` 또는 typeof에 undefined 문자열을 사용해 비교<br>
`null` : null 값이 명시적으로 할당된 상태. `===`을 사용해 비교.

#### Number type이 다른 언어들과 다른점, 왜 하나만 존재?
자바스크립트의 number type은 오직 하나만 존재<br>
자바스크립트에서는 모든 숫자를 64비트 부동 소수점으로 저장한다.<br>
(정확한 수를 저장하는 것이 아니라 근삿값으로 저장을 하기 때문에 연산 시 오차 발생 가능)

### 실행 컨텍스트
scope, hoisting, this 등의 동작원리를 담고 있는 자바스크립트의 핵심원리.<br>
실행 가능한 코드가 실행되기 위해 필요한 환경.<br>
전역 컨테스트, 함수 컨텍스트 2가지가 존재하며 전역 컨테스트 하나 생성 후 함수 호출할 때마다 함수 컨텍스트가 생성된다.<br>
컨텍스트를 생성 시에 변수객체, 스코프 체인, this가 생성된다.<br>
컨텍스트 생성 후 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프 체인을 따라 올라가며 찾는다.<br>
함수 실행이 마무리되면 함수 컨텍스트 사라짐, 페이지가 종료되면 전역 컨테스트 사라짐.

### var let const
var는 함수 레벨 스코프<br>
let, const는 블록 레벨 스코프<br>
const는 한 번 할당한 값 변경 불가능, 객체 안에 프로퍼티 변경은 가능.

### 호이스팅
모든 선언문을 해당 Scope의 최상단으로 끌어올린다.<br>
**var는 함수 레벨 스코프**라 코드 블록에 제약을 받지 않는다.<br>
**let은 블록 레벨 스코프**라 코드 블록에 제약 받음<br>
[관련 링크](https://medium.com/@_diana_lee/javascript-hoisting-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-2df9955db5c7)<br>

변수는 선언, 초기화, 할당 총 3단계를 통해 생성된다.<br>
`var` 변수의 경우 선언, 초기화가 한번에 이루어진다.<br>
즉, 스코프에 변수를 등록하고 (선언 단계), 등록된 변수에 메모리를 할당하고 undefined로 초기화(초기화 단계)하는 것이 동시에 일어난다.<br>
따라서 변수 선언문 이전에 해당 변수에 접근하더라도 변수 객체에 변수가 등록되어 있기 때문에 에러가 발생하지 않는다. 다만 undefined가 뜰 뿐.<br>

`let` 변수의 경우 선언과 초기화가 따로 이루어진다.<br>
즉, 스코프의 최상단에서 변수가 선언되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.<br>

브랜든 아이크 왈, 함수 hoisting을 통해 선언 전 호출을 가능하게 했고 이 과정에서 의도치 않은 var hoisting이 발생했다.<br>
이를 해결하기 위해 ES6에서 `let` 개념이 등장했고, 기존에 허용되던 선언 전 호출 등의 동작을 방지하는 `use strict` 키워드가 ES5에서 등장했다.

### 클로저
[JavaScript 클로저(Closure)](https://hyunseob.github.io/2016/08/30/javascript-closure/)<br>
반환된 내부함수가 자신이 선언되었을 때의 환경인 스코프를 기억하여 자신이 선언되었을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수<br>
자신이 생성될 때의 환경을 기억하는 함수<br>
- 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해
- 전역 변수의 사용을 억제하기 위해
- 캡슐화와 은닉화 (private 변수 접근 막기)

### this
[함수 호출 방식에 의해 결정되는 this](https://poiemaweb.com/js-this)<br>
자바스크립트의 경우 **함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정**된다.<br>

#### 1. 함수 호출
기본적으로 this는 전역 객체에 바인딩된다. 전역 함수는 물론이고 내부 함수의 경우에도 this는 전역 객체에 바인딩된다.<br>
자바스크립트의 **내부 함수는 일반 함수, 메소드, 콜백 함수 어디에서 선언되었든지 this는 전역 객체**를 가리킴.<br>
일반함수의 this는 window(전역)을 가리키며, 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킴

#### 2. 메소드 호출
함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다.<br>
**즉, 객체의 메소드로 호출하면 this의 값은 그 객체에 바인딩**된다.

#### 3. 생성자 함수 호출
기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.<br>
new 연산자와 함께 생성자 함수를 호출하면 this는 **생성자 함수가 암묵적으로 생성한 빈 객체에 바인딩**된다.

#### 4. `apply`, `call`, `bind` 호출
[apply, call, bind](https://wooooooak.github.io/javascript/2018/12/08/call,apply,bind/)<br>
3가지 방법 모두 this를 바인딩하기 위한 방법.<br>
`apply` : this를 바인딩하면서 함수를 호출, 두번째 인자가 배열<br>
`call` : this를 바인딩하면서 함수를 호출, 두번째 인자를 apply와 다르게 하나씩 넘김<br>
`bind` : 함수를 호출하는 것이 아닌 this가 바인딩된 새로운 함수를 리턴


### 자바스크립트의 배열은 순수한 배열이 아니다.
https://evan-moon.github.io/2019/06/15/diving-into-js-array/<br>
자바스크립트의 배열은 HashMap으로 구현되어 있다.<br>
HashMap을 구현하기 위해 연결리스트로 구현하는데 연결리스트에서 값을 찾기 위해서는 탐색해 나가면서 값을 찾는 불상사 발생.<br>
이를 해결하기 위해 타이핑된 배열(메모리 버퍼에서 원시 바이너리 데이터를 읽고 쓰는 메커니즘을 제공하는 배열과 유사한 객체) 추가

### 프로토 타입
[[Javascript ] 프로토타입 이해하기](https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67)<br>
자바스크립트는 프로토타입을 기반으로 상속을 구현해 불필요한 중복 제거<br>
즉, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해 놓음으로써 또 구현하는 것이 아니라 상위 객체인 프로토타입의 자산을 공유해 사용 가능.<br>
`__proto__` 접근자로 자신의 프로토타입에 접근 가능.<br>
프로토타입 체인 : 객체의 프로퍼티에 접근하려 할 때, 객체에 접근하려는 프로퍼티가 없으면, `__proto__` 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색.<br>
프로토타입 체인의 최상위 객체는 Object.prototype<br>
이 객체의 프로퍼티와 메소드는 모든 객체에게 상속<br>
prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴.

### 이벤트 위임
이벤트 리스너를 하위 요소에 추가하는 대신 상위 요소에 추가하는 기법.<br>
리스너는 DOM의 **이벤트 버블링**으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행됨.<br>
#### 장점
- 각 하위 항목에 이벤트 핸들러를 연결하지 않고, 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 메모리 사용 공간 줄어듦
- 제거된 요소에서 핸들러를 해제하고 새 요소에 대해 이벤트를 바인딩할 필요 없음
#### 단점
- 이벤트 위임을 사용하려면 이벤트가 반드시 버블링 되어야 하지만 몇몇 이벤트는 버블링되지 않는다.
- 컨테이너 수준에 할당된 핸들러가 응답할 필요가 있는 이벤트이든 아니든 상관없이 모든 하위 컨테이너에서 발생하는 이벤트에 응답해야 하므로 CPU 작업 부하가 늘어날 수 있다.(크게 고려 X)

### 이벤트 버블링, 캡쳐링
#### 이벤트 버블링
DOM 요소에서 이벤트가 트리거되면 리스너가 연결되어 있는 경우 이벤트 처리를 시도한 다음, 해당 이벤트가 부모에게 bubbling되고 부모에서 같은 이벤트가 발생.<br>
이 bubbling은 요소의 최상단 부모요소인 `document`까지 계속적으로 발생된다.

#### 이벤트 캡쳐링
이벤트 버블링과 반대로 최상위 요소로부터 자식에게 이벤트가 전달되는 현상<br>
어떻게 구현? `addEventListener()`에서 `capture:true` 설정<br>
이벤트 방지? `stopPropagation()`

### `use strict`
[Mozilla - use strict](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode)<br>
전체 스크립트나 개별 함수에 엄격 모드를 사용하는데 사용되는 명령문<br>
#### 장점
- 기존에 무시되던 에러들을 throw함
- JS 엔진의 최적화 작업을 어렵게 만드는 실수들을 바로잡음
- 함수의 동일한 매개 변수의 이름을 선언하는 것이 불가능
- this는 전역 컨텍스트에서 undefined
#### 단점
- 일부 개발자는 익숙하지 않은 기능이 많음
- 서로 다른 엄격 모드로 작성된 스크립트를 병합하면 문제 발생 가능

### 화살표 함수
[화살표 함수](https://poiemaweb.com/es6-arrow-function)<br>
ES6에서 추가된 스펙으로 function 표현에 비해 구문이 짧고 항상 익명으로 선언된다. 주로 콜백 함수로 사용<br>

**메소드 함수가 아닌 곳에 가장 적합하다**<br>
메소드로 정의한 화살표 함수 내부의 this는 메소드를 소유한 객체, 즉 메소드를 호출한 객체를 가리키지 않고 상위 컨택스트인 전역 객체 window를 가리킨다.<br>

**생성자로 사용 불가**<br>
생성자 함수는 prototype 프로퍼티를 가지며 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor를 사용한다. 하지만 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.

**addEventListener 함수의 콜백 함수**<br>
addEventListener 함수의 콜백 함수를 화살표 함수로 정의하면 this가 상위 컨택스트인 전역 객체 window를 가리킨다. 
따라서 addEventListener 함수의 콜백 함수 내에서 this를 사용하는 경우, function 키워드로 정의한 일반 함수를 사용하여야 한다.

#### 화살표 함수와 일반 함수의 차이?
일반 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다.<br>
반면에, 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다. **화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.**

### 익명 함수
즉시 실행이 필요한 상황에서 사용한다.<br>
변수에 할당해서(이름 붙이기도 가능) 스코프 문제 해결할 수 있다.

### JSON
JavaScript Object Notation<br>
JSON은 경량화된 파일 형식이다.<br>
자바스크립트에서 모든 객체는 연관배열(Key/Value)을 기초로 구성되어 있는데, JSON은 이러한 연관 배열을 표시하는데 매우 효과적인 방식이다.<br>
JSON은 텍스트 포멧이며 유니코드 인코딩이다. AJAX에서 JSON 방식을 사용하게 되면 `eval()` 메서드를 사용하지 않아도 키 값을 바로 불러올 수 있다.<br>
#### 장점
- 최소한의 정보를 지녀 용량 줄고 속도 빠름
- 언어에 독립적이며 사용하기 쉬움

#### 단점
- 함축적 내용의 경우 의미 파악 어려움
- 대용량 데이터 송수신에는 부적합할 수 있음

### `function foo() {}`와 `var foo = function() {}` 사이에서 foo 사용의 차이에 대해 설명
전자는 함수 선언, 후자는 함수 표현식<br>
함수 선언은 코드 블럭 자체가 실행 가능 코드가 아니지만, 함수 표현식은 특정 변수에 할당되거나 즉시 실행 가능한 코드 블럭으로서 존재하는 함수를 의미<br>
함수 선언은 호이스트되지만, 함수 표현식은 호이스트되지 않음.<br>
(의도치 않은 hoisting의 방지?)
***
## ES6
### ES6에서 추가된 스펙
let, const, rest parameter, class, destructuring, Promise, arrow function ...

### ES6 스펙에 대한 지원이 완벽하지 않은 것에 대한 해결 방안
Babel을 사용한다. ES6 이상 문법의 코드들을 브라우저가 이해할 수 있게끔 ES5 이하의 문법으로 변환

### Babel
트랜스파일러 : 한 언어로 작성된 소스코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환

### Class는 무엇이며, ES5 스펙만으로 구현 가능?
Class는 ES6에서 추가된 스펙으로 동일한 종류의 객체를 여러 개 생성할 수 있다.<br>

구현 가능. Prototype Object와 `__proto__` 속성을 사용해 클래스처럼 구현할 수 있다.

```javascript
// ES5 함수 생성자
function Person(name) {
  this.name = name;
}

// ES6 클래스
class Person {
  constructor(name) {
    this.name = name;
  }
}
```
생성자의 주요 차이점은 상속 시 발생함.
```javascript
// ES5 함수 생성자
function Student(name, studentId) {
  // 수퍼 클래스의 생성자를 호출하여 수퍼 클래스에서 상속된 멤버를 초기화합니다.
  Person.call(this, name);

  // 서브 클래스의 멤버를 초기화합니다.
  this.studentId = studentId;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

// ES6 클래스
class Student extends Person {
  constructor(name, studentId) {
    super(name);
    this.studentId = studentId;
  }
}
```
***
## DOM
[mozilla - DOM](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction)<br>
[mozilla - Node API](https://developer.mozilla.org/ko/docs/Web/API/Node)<br>
Document Object Model의 약자<br>
DOM은 문서의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공해 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다.
***
### 가비지 컬렉션(GC)
메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우 회수하는 것.<br>
JS에서 변수는 직접적으로 참조 값을 담고 있지 않고, 해당 값을 메모리 상에 저장한다. 때문에, 참조 값을 생성하고 나서 더 이상 참조할 것이 없거나 비어졌을 때 가비지 컬렉터가 동작해서 메모리 반환됨.<br>
주로 쓰이는 가비지 컬렉션 알고리즘은 마크 앤 스위프 : 현재 사용하는 값에 표시를 남긴 후 표시가 없는 값의 메모리를 회수. 루트(root)부터 해당 객체까지 닿을 수 있는지를 판단<br>
변수에서 참조를 제거하면 순환 참조 문제도 해결할 수 있고 가비지 컬렉션에 도움

> 순환 참조란?
```javascript
function problem() {
  const objectA = {};
  const objectB = {}
  objectA.otherObject = objectB;
  objectB.anotherObject = objectA;
}
```
위와 같이 객체가 서로를 참조할 때 가비지컬렉터가 동작하지 못하고 메모리 낭비 발생.<br>
null을 할당해 연결을 끊는 방법을 사용한다. 마크 앤 스위프 알고리즘 사용
***